const set_=(_,G)=>(_._=G,_),liDecode=G=>set_(_=>{let K=[],q=_.length,J=0;for(;J<q;){let[q,Y]=G(_,J);K.push(q),J=Y}return K},[]),v0_0=G=>set_(v0(G),0),v0=_=>G=>_(G,0)[0],TEXT=new TextDecoder,utf8d=TEXT.decode.bind(TEXT),get=(_,G)=>(G=`get`+G,(K,q=0)=>[new DataView(K.buffer,K.byteOffset+q,_)[G](0,!0),q+_]),varintLen=(_,G)=>{let K=_.length;for(;G<K;)if(!(_[G++]&128))return G;return G},readTag=(_,G)=>{let K=_.length,q=0,J=0,Y;for(;G<K;){if(Y=_[G],q|=(Y&127)<<J,G++,!(Y&128))return[q&7,q>>>3,G];if(J+=7,J>28)return}},unpack=_=>{let G=[],K=_.length,q=0,J;for(;q<K&&(J=readTag(_,q),J);){let[K,Y,X]=J;q=X;let Z,Q=q;switch(K){case 0:Z=varintLen(_,q);break;case 1:Z=q+8;break;case 2:{let[G,K]=decodeVarint32(_,q);Q=K,Z=K+G;break}case 5:Z=q+4;break;default:return G}G.push([Y-1,_.subarray(Q,Z)]),q=Z}return G},decodeVarint32=(_,G=0)=>{let K=0,q=0,J;do J=_[G++],K|=(J&127)<<q,q+=7;while(J&128);return[K>>>0,G]},decodeFixed32=get(4,`Uint32`),decodeFloat=get(4,`Float32`),decodeSfixed32=get(4,`Int32`),decodeDouble=get(8,`Float64`),decodeFixed64=get(8,`BigUint64`),decodeSfixed64=get(8,`BigInt64`),decodeVarint64=(_,G=0)=>{let K=0n,q=0n,J;do J=_[G++],K|=BigInt(J&127)<<q,q+=7n;while(J&128);return[K,G]},decodeUint32=decodeVarint32,decodeSint32=(_,G)=>{let[K,q]=decodeVarint32(_,G);return[K>>>1^-(K&1),q]},decodeBool=(_,G)=>{let[K,q]=decodeVarint32(_,G);return[!!K,q]},decodeInt64Based=_=>(G,K)=>{let[q,J]=decodeVarint64(G,K);return[Number(_(q)),J]},decodeInt32=decodeInt64Based(BigInt.asIntN.bind(BigInt,32)),decodeInt64=decodeInt64Based(BigInt.asIntN.bind(BigInt,64)),decodeUint64=decodeInt64Based(_=>_),decodeSint64=decodeInt64Based(_=>_>>1n^-(_&1n)),string=set_(utf8d,``),bytes=set_(_=>_,new Uint8Array),bool=set_(v0(decodeBool),!1),boolLi=liDecode(decodeBool),double=v0_0(decodeDouble),doubleLi=liDecode(decodeDouble),fixed32=v0_0(decodeFixed32),fixed32Li=liDecode(decodeFixed32),fixed64=v0_0(decodeFixed64),fixed64Li=liDecode(decodeFixed64),float=v0_0(decodeFloat),floatLi=liDecode(decodeFloat),int32=v0_0(decodeInt32),int32Li=liDecode(decodeInt32),int64=v0_0(decodeInt64),int64Li=liDecode(decodeInt64),sfixed32=v0_0(decodeSfixed32),sfixed32Li=liDecode(decodeSfixed32),sfixed64=v0_0(decodeSfixed64),sfixed64Li=liDecode(decodeSfixed64),sint32=v0_0(decodeSint32),sint32Li=liDecode(decodeSint32),sint64=v0_0(decodeSint64),sint64Li=liDecode(decodeSint64),uint32=v0_0(decodeUint32),uint32Li=liDecode(decodeUint32),uint64=v0_0(decodeUint64),uint64Li=liDecode(decodeUint64),map=(_,G)=>[$([_,G])],$=_=>{let G=[],K=[],q=new Set;_.forEach((_,J)=>{Array.isArray(_)?(G[J]=[],K[J]=_[0],q.add(J)):(G[J]=_._,K[J]=_)});let J=_=>{let J=structuredClone(G);for(let[G,Y]of unpack(_)){let _=K[G];if(_){let K=_(Y);q.has(G)?J[G].push(K):J[G]=K}}return J};return J._=G,J},EchoD=$([string]),Test1D=$([int32,string]),Test2D=$([double,float,int32,int64,uint32,uint64,sint32,sint64,fixed32,fixed64,sfixed32,sfixed64,bool,string,bytes,doubleLi,floatLi,int32Li,int64Li,uint32Li,uint64Li,sint32Li,sint64Li,fixed32Li,fixed64Li,sfixed32Li,sfixed64Li,boolLi,[string],[bytes],Test1D,[Test1D],map(int32,string),int32,int32Li]);var tree_shaking_decode_default=EchoD;export{tree_shaking_decode_default as default};